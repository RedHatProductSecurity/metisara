#!/usr/bin/env python3

import sys
import subprocess
import argparse
from pathlib import Path
from .config.manager import ConfigManager
from .utils.file_manager import auto_move_csv_from_downloads, download_csv_from_google_sheets

# Import version from package
from . import __version__


def clean_workspace():
    """Clean all project generated files"""
    import shutil
    
    workspace_dir = Path.cwd() / 'workspace'
    
    print("üßπ Cleaning project generated files...")
    
    files_removed = 0
    dirs_removed = 0
    
    # Remove workspace directory and all contents
    if workspace_dir.exists():
        print(f"   üóÇÔ∏è  Removing workspace/ directory...")
        try:
            shutil.rmtree(workspace_dir)
            dirs_removed += 1
            print(f"   ‚úÖ Removed workspace/ directory")
        except Exception as e:
            print(f"   ‚ùå Error removing workspace/: {e}")
    
    # Remove any issue report zip files in current directory
    zip_files = list(Path.cwd().glob("metis-issue-report-*.zip"))
    if zip_files:
        print(f"   üì¶ Removing {len(zip_files)} issue report zip file(s)...")
        for zip_file in zip_files:
            try:
                zip_file.unlink()
                files_removed += 1
                print(f"   ‚úÖ Removed {zip_file.name}")
            except Exception as e:
                print(f"   ‚ùå Error removing {zip_file.name}: {e}")
    
    # Summary
    if files_removed > 0 or dirs_removed > 0:
        print(f"‚úÖ Cleanup complete!")
        print(f"   üìä Summary: {dirs_removed} directories and {files_removed} files removed")
    else:
        print("‚úÖ No generated files found to clean")
    
    return True

def create_issue_report():
    """Create a zip file containing workspace subdirectories for issue reporting"""
    import zipfile
    from datetime import datetime
    
    # Create workspace directory structure if needed
    workspace_dir = Path.cwd() / 'workspace'
    if not workspace_dir.exists():
        print("‚ùå No workspace directory found. Please run metis first to generate workspace content.")
        return False
    
    # Create timestamp for the zip file
    timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
    zip_filename = workspace_dir / f"metis-issue-report-{timestamp}.zip"
    
    print(f"üì¶ Creating issue report: {zip_filename}")
    
    try:
        with zipfile.ZipFile(zip_filename, 'w', zipfile.ZIP_DEFLATED) as zipf:
            # Add all files from workspace subdirectories
            subdirs = ['input', 'output', 'config', 'temp']
            total_files = 0
            
            for subdir in subdirs:
                subdir_path = workspace_dir / subdir
                if subdir_path.exists():
                    print(f"   üìÅ Adding {subdir}/ directory...")
                    for file_path in subdir_path.rglob('*'):
                        if file_path.is_file():
                            # Create archive path relative to workspace
                            arcname = file_path.relative_to(workspace_dir)
                            zipf.write(file_path, arcname)
                            total_files += 1
                else:
                    print(f"   ‚ö†Ô∏è  Skipping {subdir}/ (directory not found)")
            
            # Add the main config file if it exists
            config_file = Path.cwd() / 'metisara.conf'
            if config_file.exists():
                print(f"   üìÑ Adding metisara.conf...")
                zipf.write(config_file, 'metisara.conf')
                total_files += 1
        
        print(f"‚úÖ Issue report created successfully!")
        print(f"   üì¶ File: {zip_filename}")
        print(f"   üìä Contains: {total_files} files")
        print(f"   üí° Attach this file when reporting issues")
        return True
        
    except Exception as e:
        print(f"‚ùå Error creating issue report: {e}")
        return False


def get_ai_disclaimer():
    """Generate AI disclaimer for generated files"""
    from datetime import datetime
    current_date = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    return f"""# ============================================================================
# AI-GENERATED CONTENT DISCLAIMER
# ============================================================================
# This file was automatically generated by Claude (Anthropic's AI assistant)
# 
# IMPORTANT WARNINGS:
# - Review all code, logic, and configurations before production use
# - Verify security settings, credentials, and access permissions
# - Test thoroughly in development environment first
# - AI-generated code may contain errors or security vulnerabilities
# 
# Generated: {current_date}
# Tool: Metisara v{__version__} Project Management Automation
# ============================================================================
"""

def run_command(command, description, check_success=True):
    """Run a subprocess command with error handling"""
    print(f"\nüîÑ {description}...")
    try:
        result = subprocess.run(command, capture_output=True, text=True, check=True)
        print(result.stdout)
        if result.stderr:
            print(f"‚ö†Ô∏è  Warnings: {result.stderr}")
        return True
    except subprocess.CalledProcessError as e:
        print(f"‚ùå Error: {e}")
        if e.stdout:
            print(f"Output: {e.stdout}")
        if e.stderr:
            print(f"Error details: {e.stderr}")
        if check_success:
            return False
        return True
    except FileNotFoundError:
        print(f"‚ùå Command not found: {' '.join(command)}")
        return False

def check_prerequisites():
    """Check if required modules exist"""
    script_dir = Path(__file__).parent
    required_modules = [
        script_dir / 'processors' / 'csv_processor.py',
        script_dir / 'jira' / 'ticket_creator.py',
        script_dir / 'utils' / 'file_manager.py',
        script_dir / 'config' / 'manager.py'
    ]
    
    missing_files = []
    for file in required_modules:
        if not file.exists():
            missing_files.append(str(file.relative_to(script_dir.parent.parent)))
    
    if missing_files:
        print("‚ùå Missing required modules:")
        for file in missing_files:
            print(f"   - {file}")
        return False
    
    return True


def main():
    print("Metis - Metisara Workflow Automation")
    print("=" * 40)
    print("üèõÔ∏è  Wisdom and planning for your project management")
    
    # Parse command line arguments
    parser = argparse.ArgumentParser(
        prog='metis',
        description='Metisara - Automated JIRA project management workflow',
        epilog='''
Examples:
  ./metis --pretend                    # Dry-run mode (no tickets created)
  ./metis --force --pretend            # Force refresh CSV from Downloads  
  ./metis --generate-config            # Generate configuration only
  ./metis YOUR_API_TOKEN               # Create actual JIRA tickets
  ./metis --skip-auto-move TOKEN       # Use existing CSV file
  ./metis --google-sheets "URL" TOKEN  # Download from Google Sheets

Google Sheets:
  ./metis --google-sheets "https://docs.google.com/spreadsheets/d/ABC123/edit" --pretend

Configuration:
  - Edit metisara.conf for JIRA URL, username, and file paths
  - CSV templates go in workspace/input/
  - Processed files saved to workspace/output/
  - Configuration files stored in workspace/config/
        ''',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument('--version', action='version', version=f'Metisara {__version__}')
    
    parser.add_argument('--dry-run', '--pretend', action='store_true',
                       help='Run in dry-run mode - simulate ticket creation without actually creating JIRA tickets')
    
    parser.add_argument('--skip-auto-move', action='store_true',
                       help='Skip automatic CSV file moving from Downloads folder (assumes file is already in workspace)')
    
    parser.add_argument('--force', action='store_true',
                       help='Force move CSV file from Downloads even if destination file already exists in workspace')
    
    parser.add_argument('--generate-config', action='store_true',
                       help='Generate placeholder configuration from CSV file instead of processing tickets')
    
    parser.add_argument('--report-issue', action='store_true',
                       help='Create a zip file with workspace contents for issue reporting (WARNING: may contain names and email addresses - do not upload online)')
    
    parser.add_argument('--clean', action='store_true',
                       help='Clean all project generated files (workspace directory, logs, and zip files)')
    
    parser.add_argument('--google-sheets', type=str, metavar='URL',
                       help='Download CSV from Google Sheets URL instead of local Downloads folder')
    
    parser.add_argument('api_token', nargs='?',
                       help='JIRA API token for creating tickets (optional if using .env file or running in dry-run mode)')
    
    args = parser.parse_args()
    
    # Set up automatic logging
    from datetime import datetime
    import sys
    
    # Create temp directory if it doesn't exist
    temp_dir = Path.cwd() / 'workspace' / 'temp'
    temp_dir.mkdir(parents=True, exist_ok=True)
    
    # Create log file with timestamp
    timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
    log_file = temp_dir / f"metis-output-{timestamp}.log"
    
    # Set up output redirection to both console and log file
    class TeeOutput:
        def __init__(self, file_path):
            self.terminal = sys.stdout
            self.log_file = open(file_path, 'w', encoding='utf-8')
        
        def write(self, message):
            self.terminal.write(message)
            self.log_file.write(message)
            self.log_file.flush()
        
        def flush(self):
            self.terminal.flush()
            self.log_file.flush()
        
        def close(self):
            self.log_file.close()
    
    # Redirect stdout to both terminal and log file
    tee = TeeOutput(log_file)
    original_stdout = sys.stdout
    sys.stdout = tee
    
    print(f"üìù Log file: {log_file}")
    print()
    
    # Handle --clean flag
    if args.clean:
        print("üßπ Cleaning project files...")
        success = clean_workspace()
        # Close log file and restore stdout
        sys.stdout = original_stdout
        tee.close()
        if success:
            print(f"üìù Log saved to: {log_file}")
            sys.exit(0)
        else:
            sys.exit(1)
    
    # Handle --report-issue flags
    if args.report_issue:
        print("üêõ Creating issue report...")
        success = create_issue_report()
        # Close log file and restore stdout
        sys.stdout = original_stdout
        tee.close()
        if success:
            print(f"üìù Log saved to: {log_file}")
            sys.exit(0)
        else:
            sys.exit(1)
    
    
    # Check prerequisites
    if not check_prerequisites():
        print("\n‚ùå Prerequisites check failed. Please ensure all required files exist.")
        sys.exit(1)
    
    # Load configuration
    try:
        config_manager = ConfigManager()
        config = config_manager.load_config()
        
        # Validate configuration (skip JIRA validation in dry-run mode)
        config_manager.validate_config(config, skip_jira_validation=args.dry_run)
        
        csv_input = config['csv_input']
        csv_output = config['csv_output']
        jira_url = config['jira_url']
        username = config['username']
        # Get Google Sheets URL from config if not provided via command line
        google_sheets_url = config.get('google_sheets_url')
        if not args.google_sheets and google_sheets_url:
            args.google_sheets = google_sheets_url
    except Exception as e:
        print(f"‚ùå Configuration error: {e}")
        print("\nüí° Please update your metisara.conf file with your actual JIRA instance details.")
        sys.exit(1)
    
    print(f"\nüìã Configuration:")
    print(f"   Input CSV: {csv_input}")
    print(f"   Output CSV: {csv_output}")
    print(f"   JIRA URL: {jira_url}")
    print(f"   Username: {username}")
    if args.google_sheets:
        print(f"   Google Sheets: {args.google_sheets}")
    if args.dry_run:
        print("   Mode: üîç DRY RUN (no JIRA tickets will be created)")
    
    # Step 1: Obtain CSV file (from Downloads, Google Sheets, or existing file)
    if args.google_sheets:
        print(f"\nüìÅ Step 1: Downloading CSV from Google Sheets...")
        success = download_csv_from_google_sheets(args.google_sheets, force=args.force)
        if not success:
            print("‚ùå Failed to download CSV from Google Sheets.")
            sys.exit(1)
        print(f"‚úÖ CSV file downloaded from Google Sheets to: {csv_input}")
    elif not args.skip_auto_move:
        if Path(csv_input).exists() and not args.force:
            print(f"\nüìÅ Step 1: {csv_input} already exists in current directory, skipping auto-move")
        else:
            if args.force and Path(csv_input).exists():
                print(f"\nüìÅ Step 1: Force moving {csv_input} from Downloads...")
            else:
                print(f"\nüìÅ Step 1: Moving {csv_input} from Downloads...")
            print(f"\nüîÑ Moving {csv_input} from Downloads...")
            success = auto_move_csv_from_downloads(force=args.force)
            if not success:
                print("‚ùå Failed to move CSV file. Use --skip-auto-move if file is already in place.")
                sys.exit(1)
    else:
        print(f"\nüìÅ Step 1: Skipped auto-move (assuming {csv_input} is already present)")
        # Check for the file in multiple possible locations
        csv_path = Path(csv_input)
        possible_paths = [
            csv_path,  # Direct path as specified in config
            Path("workspace/input") / csv_input,  # In workspace/input directory
            Path("workspace/input") / csv_path.name,  # Just filename in workspace/input
        ]
        
        file_found = False
        actual_path = None
        for path in possible_paths:
            if path.exists():
                file_found = True
                actual_path = path
                break
        
        if not file_found:
            print(f"‚ùå {csv_input} not found in any of these locations:")
            for path in possible_paths:
                print(f"   - {path}")
            print("üí° Try placing the file in workspace/input/ directory")
            sys.exit(1)
        else:
            # Update csv_input to the actual found path for subsequent processing
            csv_input = str(actual_path)
            print(f"‚úÖ Found CSV file at: {csv_input}")
    
    # Step 2: Process CSV (generate config or process placeholders)
    if args.generate_config:
        print(f"\n‚öôÔ∏è  Step 2: Generating configuration from {csv_input}...")
        process_cmd = [sys.executable, str(Path(__file__).parent / 'processors' / 'csv_processor.py'), '--generate-config']
        if args.skip_auto_move:
            process_cmd.append('--skip-auto-move')
        if args.google_sheets:
            process_cmd.extend(['--google-sheets', args.google_sheets])
        if args.force:
            process_cmd.append('--force')
        
        success = run_command(process_cmd, "Generating configuration from CSV")
        if not success:
            print("‚ùå Failed to generate configuration")
            sys.exit(1)
        
        print("\n‚úÖ Configuration generation complete!")
        print("üìù Review the generated csv_replacements.json file and run again without --generate-config")
        sys.exit(0)
    else:
        # Always generate fresh csv_replacements.json from current CSV template
        print(f"\n‚öôÔ∏è  Step 2a: Generating fresh configuration from {csv_input}...")
        generate_cmd = [sys.executable, str(Path(__file__).parent / 'processors' / 'csv_processor.py'), '--generate-config']
        if args.skip_auto_move:
            generate_cmd.append('--skip-auto-move')
        if args.google_sheets:
            generate_cmd.extend(['--google-sheets', args.google_sheets])
        if args.force:
            generate_cmd.append('--force')
        
        success = run_command(generate_cmd, "Generating configuration from CSV")
        if not success:
            print("‚ùå Failed to generate configuration")
            sys.exit(1)
        
        print("‚úÖ Configuration generated successfully!")
        
        print(f"\nüîÑ Step 2b: Processing placeholders in {csv_input}...")
        process_cmd = [sys.executable, str(Path(__file__).parent / 'processors' / 'csv_processor.py')]
        if args.skip_auto_move:
            process_cmd.append('--skip-auto-move')
        if args.google_sheets:
            process_cmd.extend(['--google-sheets', args.google_sheets])
        if args.force:
            process_cmd.append('--force')
        
        success = run_command(process_cmd, f"Processing placeholders to create {csv_output}")
        if not success:
            print("‚ùå Failed to process CSV placeholders")
            sys.exit(1)
    
    # Step 3: Create JIRA tickets
    print(f"\nüé´ Step 3: Creating JIRA tickets from {csv_output}...")
    
    # Build create tickets command
    create_cmd = [sys.executable, str(Path(__file__).parent / 'jira' / 'ticket_creator.py')]
    
    if args.dry_run:
        create_cmd.append('--dry-run')
    elif args.api_token:
        create_cmd.append(args.api_token)
    
    action = "Simulating JIRA ticket creation" if args.dry_run else "Creating JIRA tickets"
    success = run_command(create_cmd, action)
    
    if not success:
        print("‚ùå Failed to create JIRA tickets")
        sys.exit(1)
    
    # Summary
    print(f"\n‚úÖ Metisara workflow completed successfully!")
    print(f"üìä Summary:")
    print(f"   üìÅ Processed CSV: {csv_input} ‚Üí {csv_output}")
    if args.dry_run:
        print(f"   üîç Mode: Dry-run (no actual JIRA tickets created)")
    else:
        print(f"   üé´ JIRA tickets created in: {jira_url}")
    
    print(f"\nüèõÔ∏è  Metis has guided your project planning successfully!")
    
    # Close log file and restore stdout
    sys.stdout = original_stdout
    tee.close()
    print(f"üìù Log saved to: {log_file}")

if __name__ == "__main__":
    main()